/*
 * This file is part of the Nano-Shell Simulation Project.
 * 
 * Copyright (C) 2025 Alessandro Veltri
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#include <iostream>
#include <iomanip>
#include <fstream>
#include <stdlib.h>
#include <armadillo>
#include "headers/math33.H"
#include "headers/single.H"
#include "headers/cup.H"
#include "headers/ns_ISS.H"

using namespace std;

/** Compila con: 
g++ -Wall -I/usr/include/ -L/usr/local/lib ../src/QS_OB_anl_time.cxx -o ../bin/anl -lgsl -lgslcblas -lm -larmadillo
**/

double pi = acos(-1.);

complex<double> p1(complex<double> eps_inf, complex<double>  sig, complex<double>  Pi, complex<double>  q, double eps_b){
        complex<double> alph =((eps_inf-eps_b)-2.*Pi-(q+4.*sig))/(eps_inf+2.*eps_b);
        return alph;
        }

int main(int argc, char** argv){
    double omeeV;
        if (argc==1){
            cout<<endl<<"  Usage: "<<argv[0]<<" <omega in eV>"<<endl<<endl;
            exit(0);
            }
    omeeV=atof(argv[1]);
    complex<double> img = complex<double> (0., 1.);
    double dome, ome, omemi, omema, eps_b, gamd, GG, ompHz, ome21;// a3,
    int omi, omeN=5000;
    complex<double> eps1, eps_inf, eps2, alph, alph_d;
    complex<double> Ome, lam1, lam2, lam3, Del, D1, D2;
    complex<double> C[4], R[4];
    complex<double> Pi, sig, q, Pi0, sig0, q0;
    char mtl[16], mdl[16], sol[16], active[16];
    double t, dt=0.001, T, to, t0=0., tpump;
    nanosphere ns;
    ifstream nano("../data/input/nanosphere_eV.dat");
    if (!nano) {
        cerr << "Error: Cannot open input file" << endl;
        return 1;
    }
    ifstream time("../data/input/time.dat");
    if (!time) {
        cerr << "Error: Cannot open input file" << endl;
        return 1;
    }
    ofstream stat("../data/output/stationary.dat");
    if (!stat) {
        cerr << "Error: Cannot open output file" << endl;
        return 1;
    }
    ofstream lmda("../data/output/lambda.dat");
    if (!lmda) {
        cerr << "Error: Cannot open output file" << endl;
        return 1;
    }
    ofstream comp("../data/output/compounds.dat");
    if (!comp) {
        cerr << "Error: Cannot open output file" << endl;
        return 1;
    }
    ofstream dyna("../data/output/QS_OB_anltime.dat");
    if (!dyna) {
        cerr << "Error: Cannot open output file" << endl;
        return 1;
    }
    ofstream omga("../data/output/omega.dat");
    if (!omga) {
        cerr << "Error: Cannot open output file" << endl;
        return 1;
    }

    omga<<omeeV<<endl;

    nano>>ns.r1>>ns.Dome>>ns.ome_0>>GG>>omemi>>omema>>mtl>>mdl>>active>>sol;
    time>>T>>tpump;
    
    if (GG==0.) GG=__DBL_EPSILON__; // zero is problematic as a value for GG set to the smaller number the machine allows
    ns.G=GG;
//     a3=ns.r1*ns.r1*ns.r1;
    ns.init();
    ns.set_metal(mtl,mdl,1);
    eps_b=ns.set_host(sol);
    ns.set_active(active);
    dome  = (omema-omemi)/omeN;
    ome21=ns.ome_0/ns.Ome_p;
    
    ompHz = eV2erg*ns.Ome_p/he;	//converto in Hz

    stat<<"# * STATIC * "<<endl;
    stat<<"#"<<endl;
    stat<<"# file generated by ** naked.cxx ** "<<endl;
    stat<<"#"<<endl;
    stat<<"# PARAMETERS: "<<endl;
    stat<<"# r1 = "<<ns.r1<<endl;
    stat<<"# G = "<<ns.G<<endl;
    stat<<"# "<<mdl<<" model utilized for metal "<<endl;
    stat<<"# ------------- "<<endl;
    stat<<"# ome     real(alph)\timag(alph)"<<endl;
    stat<<"#"<<endl;


    comp<<"# * COMPONENTS * "<<endl;
    comp<<"#"<<endl;
    comp<<"# file generated by ** resoeV.cxx ** "<<endl;
    comp<<"#"<<endl;
    comp<<"# PARAMETERS: "<<endl;
    comp<<"# r1 = "<<ns.r1<<"\tr2 = "<<ns.r2<<"\tr1/r2 = "<<ns.rap<<endl;
    comp<<"# "<<mdl<<" model utilized for metal "<<endl;
    comp<<"# ------------- "<<endl;
    comp<<"# ome\treal(eps1)\timag(eps1)\treal(eps2)\timag(eps2)"<<endl;
    comp<<"#"<<endl;

   
    for (omi=0; omi<=omeN; omi++){
        omeeV = omemi + omi*dome;
        gamd = 0.5*ns.Gam_d/ns.Ome_p;
        eps1 = ns.metal(omeeV);
        eps2 = ns.active(omeeV,eps_b);
        ome  = omeeV/ns.Ome_p;
        eps_inf=eps1+1./(ome*(ome+2.*img*gamd));
        
        lam1=img*(ome-ome21)-0.5*ns.Dome/ns.Ome_p;    
        Ome=ome*(ome+2.*img*gamd)/(2.*(gamd-img*ome));
        
        D1=Ome*(eps1+2.*eps_b)+lam1*(eps_inf+2.*eps2);
        Del=sqrt(D1*D1-4.*lam1*Ome*(eps1+2.*eps2)*(eps_inf+2.*eps_b));
        D2=2.*(eps_inf+2.*eps_b);
        lam2=(eps1+2.*eps_b)*Ome+(eps_inf+2.*eps2)*lam1+Del; //soluzione con +∆
        lam3=lam2-2.*Del; //soluzione con -∆
        lam2=lam2/D2;
        lam3=lam3/D2;

        
        alph =(eps1-eps2)/(eps1+2.*eps2);
        
        stat<<"  "<<setw(8)<<setiosflags (ios::left)<<omeeV<<         // 1 lambda
            "\t"<<setw(11)<<setiosflags (ios::left)<<real(alph)<<   // 2 Re(alpha)
            "\t"<<setw(11)<<setiosflags (ios::left)<<imag(alph)<<   // 3 Im(alpha)
            endl;

        comp<<"  "<<setw(8)<<setiosflags (ios::left)<<omeeV<<         // 1 lambda
            "\t"<<setw(11)<<setiosflags (ios::left)<<real(eps1)<<   // 2 Re(eps1)
            "\t"<<setw(11)<<setiosflags (ios::left)<<imag(eps1)<<   // 3 Im(eps1)
            "\t"<<setw(11)<<setiosflags (ios::left)<<real(eps2)<<   // 4 Re(eps2)
            "\t"<<setw(11)<<setiosflags (ios::left)<<imag(eps2)<<   // 5 Im(eps2)

            endl;
            
        lmda<<"  "<<setw(8)<<setiosflags (ios::left)<<omeeV<<         // 1 lambda
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*real(lam2)<<   // 2 Re(lam2)
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*imag(lam2)<<   // 3 Im(lam2)
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*real(lam3)<<   // 4 Re(lam3)
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*imag(lam3)<<   // 5 Im(lam3)
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*real(lam1)<<   // 6 Re(lam1)
            "\t"<<setw(11)<<setiosflags (ios::left)<<ns.Ome_p*imag(lam1)<<   // 7 Im(lam1)
            endl;

        }
        omeeV=atof(argv[1]);
        ome  = omeeV/ns.Ome_p;
        gamd = 0.5*ns.Gam_d/ns.Ome_p;
        eps1 = ns.metal(omeeV);
        eps_inf=eps1+1./(ome*(ome+2.*img*gamd));
        eps2 = ns.active(omeeV,eps_b);
        alph =(eps1-eps2)/(eps1+2.*eps2);
        

        omga<<T<<endl;
        omga<<real(alph)<<" "<<imag(alph)<<endl;
        int Nt=T/dt;
        int Nprint=Nt;
        if(Nt>1000) Nprint=1000;

        int iprint=Nt/Nprint;

        
        ns.G=__DBL_EPSILON__;//0.0001;
        eps1 = ns.metal(omeeV);
        lam1=img*(ome-ome21)-0.5*ns.Dome/ns.Ome_p;    
        Ome=ome*(ome+2.*img*gamd)/(2.*(gamd-img*ome));
        Pi0  = complex<double> (0., 0.);
        q0   = complex<double> (0., 0.);
        sig0 = complex<double> (0., 0.);
        for (int i=0; i<=Nt; i++){
        t=i*dt;
        if(t == tpump && abs(GG)>__DBL_EPSILON__){
            ns.G = GG;
            Pi0  = Pi;
            q0   = q;
            sig0 = sig;
            t0   = t;
            }
        eps2 = ns.active(omeeV,eps_b);
        D1=Ome*(eps1+2.*eps_b)+lam1*(eps_inf+2.*eps2);
        Del=sqrt(D1*D1-4.*lam1*Ome*(eps1+2.*eps2)*(eps_inf+2.*eps_b));
        D2=2.*(eps_inf+2.*eps_b);
        lam2=(eps1+2.*eps_b)*Ome+(eps_inf+2.*eps2)*lam1+Del; //soluzione con +∆
        lam3=lam2-2.*Del; //soluzione con -∆
        lam2=lam2/D2;
        lam3=lam3/D2;

        alph =(eps1-eps2)/(eps1+2.*eps2);

        //a³=1 and E0=1 C[3]=c2(3), C[2]=c2(2), C[1]=c1(1)
        C[3]=((eps2-eps_b)*(lam3-Ome))/(Ome*(lam2-lam3)*(Ome-lam1))*(0.5*Ome*(lam2-3.*lam1)+lam1*lam2-lam2*(lam1-Ome)*alph)/2.
            +(lam1*(eps2-eps_b)*(lam3-Ome)*(lam2-Ome)*q0+2.*Ome*(lam2-lam1)*sig0)/(2.*(eps1-eps_inf)*Ome*(lam2-lam3)*(Ome-lam1));
        C[2]=-C[3]-(eps2-eps_b)*(0.5+alph)/2.+sig0;
        C[1]=-(eps2-eps_b)/2.+Pi0;
        R[2]=2.*(eps1-eps_inf)/(eps2-eps_b)*(lam2-lam1)/(lam2-Ome)*Ome/lam1;
        R[3]=2.*(eps1-eps_inf)/(eps2-eps_b)*(lam3-lam1)/(lam3-Ome)*Ome/lam1;

        to=(t-t0)*1.e-12*ompHz;

        Pi  = C[1]*exp(lam1*to)+(eps2-eps_b)/2.;
        sig = -0.5*C[1]*exp(lam1*to)+C[2]*exp(lam2*to)+C[3]*exp(lam3*to)+(eps2-eps_b)*alph/2.;
        q   = C[2]*R[2]*exp(lam2*to)+C[3]*R[3]*exp(lam3*to)-2.*(eps_inf-eps1)*(alph-1.)/2.;

        alph_d =p1(eps_inf, sig, Pi, q, eps_b);
        
        if(i%iprint==0)
            dyna<<"  "<<setw(8)<<setiosflags (ios::left)<<t<<               // 1 time (ps)
                "\t"<<setw(13)<<setiosflags (ios::left)<<real(alph_d)<<     // 2 Re(alpha)
                "\t"<<setw(13)<<setiosflags (ios::left)<<imag(alph_d)<<     // 3 Im(alpha)
                endl;
            }
    return 0;
    }
